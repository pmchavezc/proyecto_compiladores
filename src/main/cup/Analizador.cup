package org.example;
import java_cup.runtime.*;

parser code {:
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            if (s.left >= 0) {
                m.append(" en línea ").append(s.left + 1); 
            }
            if (s.right >= 0) {
                m.append(", columna ").append(s.right + 1);
            }
            if (s.value != null) {
                m.append(": '").append(s.value).append("'");
            }
        }
        m.append(" : ").append(message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    public void report_program_recognized() {
        System.out.println("Programa reconocido correctamente.");
    }
:};

/* Terminales: Coinciden con los tokens que devuelve JFlex */
terminal DEFINE, FUNCTION, RETURN, IF, ELSE, ELSEIF, WHILE, LOOP, END, THEN, DO, PRINT;
terminal SEMICOLON, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, ASSIGN;
terminal PLUS, MINUS, MULT, DIV;
terminal EQEQ, NEQ, GTE, LTE, GT, LT;
terminal AND, OR, NOT;

terminal Integer NUMERO;      // Declaramos el tipo del valor que viene de JFlex
terminal Float FLOTANTE;      // Declaramos el tipo del valor que viene de JFlex
terminal String CADENA;      // Declaramos el tipo del valor que viene de JFlex
terminal String IDENTIFICADOR; // Declaramos el tipo del valor que viene de JFlex
terminal TRUE, FALSE; // Literales booleanos

terminal TYPE_INT, TYPE_BOOLEAN, TYPE_FLOAT, TYPE_STRING;

/* No terminales */
nonterminal program;
nonterminal statement;
nonterminal statementList;
nonterminal expr;
nonterminal functionDef;
nonterminal exprList;
nonterminal paramList;
nonterminal paramListOpt;
nonterminal elseIfList;
nonterminal elsePart;


// Precedencia y asociatividad
precedence left OR;
precedence left AND;
precedence left EQEQ, NEQ;
precedence left LT, LTE, GT, GTE;
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence right NOT;

start with program;

program ::= statementList:s {: parser.report_program_recognized(); :} ;

statementList ::= statementList:s statement:st
                | statement:st
                ;

statement ::= DEFINE IDENTIFICADOR:id ASSIGN expr:e SEMICOLON
            | functionDef
            | IF expr:cond THEN statementList:ifBody elseIfList:elseIfs elsePart:elseP END
            | WHILE expr:cond DO statementList:loopBody END
            | PRINT exprList:printItems SEMICOLON
            ;

elseIfList ::= elseIfList:list ELSEIF expr:cond THEN statementList:body
              | /* vacío */
              ;

elsePart ::= ELSE statementList:body
            | /* vacío */
            ;

functionDef ::= FUNCTION IDENTIFICADOR:id LPAREN paramListOpt:params RPAREN statementList:body END
              ;

paramListOpt ::= paramList:p
                | /* vacío */
                ;

paramList ::= IDENTIFICADOR:id
            {: RESULT = id; :}
            | paramList:list COMMA IDENTIFICADOR:id
            {: RESULT = list + ", " + id; :}
            ;

exprList ::= expr:e
            | exprList:list COMMA expr:e
            ;

expr ::= expr:e1 PLUS expr:e2      {: RESULT = "(" + e1 + " + " + e2 + ")"; :}
        | expr:e1 MINUS expr:e2    {: RESULT = "(" + e1 + " - " + e2 + ")"; :}
        | expr:e1 MULT expr:e2     {: RESULT = "(" + e1 + " * " + e2 + ")"; :}
        | expr:e1 DIV expr:e2      {: RESULT = "(" + e1 + " / " + e2 + ")"; :}
        | expr:e1 LT expr:e2       {: RESULT = "(" + e1 + " < " + e2 + ")"; :}
        | expr:e1 GT expr:e2       {: RESULT = "(" + e1 + " > " + e2 + ")"; :}
        | expr:e1 LTE expr:e2      {: RESULT = "(" + e1 + " <= " + e2 + ")"; :}
        | expr:e1 GTE expr:e2      {: RESULT = "(" + e1 + " >= " + e2 + ")"; :}
        | expr:e1 EQEQ expr:e2     {: RESULT = "(" + e1 + " == " + e2 + ")"; :}
        | expr:e1 NEQ expr:e2      {: RESULT = "(" + e1 + " != " + e2 + ")"; :}
        | expr:e1 AND expr:e2      {: RESULT = "(" + e1 + " && " + e2 + ")"; :}
        | expr:e1 OR expr:e2       {: RESULT = "(" + e1 + " || " + e2 + ")"; :}
        | NOT expr:e               {: RESULT = "!" + e; :}
        | LPAREN expr:e RPAREN     {: RESULT = e; :}
        | NUMERO:n                 {: RESULT = n.toString(); :}
        | FLOTANTE:f               {: RESULT = f.toString(); :}
        | IDENTIFICADOR:id         {: RESULT = id; :}
        | CADENA:s                 {: RESULT = "\"" + s + "\""; :}
        | TRUE                     {: RESULT = "TRUE"; :}
        | FALSE                    {: RESULT = "FALSE"; :}
        ;